# Отчет по лабораторной работе
## по курсу "Функциональное программирование на Прологе"

### Студенты: 

| ФИО       | Роль в проекте                     | Оценка       |
|-----------|------------------------------------|--------------|
| Лисин Р.С. | Проработка синтаксиса языка, интерпретатор |          |
| Мальцев И.Д. | Синтаксический анализ, написание отчёта |       |
| Фролов М.А.| Лексический анализ, интерпретатор |      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Пример программы

Простейшей программой c использованием замыканий может быть
`(let id 1) (makefun arg {} (+ id 1)) (arg)`,
которая после работы программы превращается в число 2.

## Синтаксическое дерево

Синтаксическое дерево представляется в виде дерева (только один корень), которое состоит их элементов типа DUMMYLIST:

```
type Expr =
    | NUMBER of double
    | STRING of string
    | BOOL of bool
    | ID of string
    | COND of Expr * Expr * Expr               // DUMMYLIST * DUMMYLIST * DUMMYLIST
    | LET of string * Expr                     // string * DUMMYLIST
    | SET of string * Expr                     // stirng * DUMMYLIST
    | FUNC of string * Expr * Expr * env * int // string * DUMMYARGLIST * DUMMYLIST * env * arity
    | CALL of string * Expr * int              // string * DUMMYLIST * arity
    | OP of string * Expr list
    | PRINT of Expr

    | DUMMYARGLIST of Expr list
    | DUMMYLIST of Expr list
    | DUMMYOP of string
    | DUMMY of string
and env = Map<string, Expr>
```
|Тип|Описание|
|---|--------|
|NUMBER| числа|
|STRING| строки|
|BOOL| булевые значения|
|ID| именованные переменные|
|COND| условные выражения (условие, то, иначе)|
|LET| создание именованных переменных (имя, привязываемое значение [не вычисляется при привязке])|
|FUNC| объявление функции(имя функции, список аргументов, тело, замыкание, количество аргументов)|
|CALL| вызов функции(имя вызываемой функции, список аргументов, арность)|
|OP| операторы (булевые, числовые или операторы отношения) и список параметров|

Поступающая на вход программе строка, разбивается на токены, последовательность которых парсится:
происходит парсинг токенов по отдельности, после чего обрабатываются целые выражения (путём сопоставления с заранее составленными шаблонами) в тип DUMMYLIST.

Внутри DUMMYLIST лежит последовательность подвыражений, которые нужны вычислить для получения значения целого выражения, в нём может лежать как один элемент, например, число, так и действительно последовательность действий.
Все элементы полученного дерева представляют являются элементами типа DUMMYLIST. 

Тип DUMMYARGLIST используется для определения аргументов функции, которые заключены между фигурными скобками -- они собираются в одной переменной и таким образом помечаются для дальнейшего применения нужного структурного шаблона (функция это [ИМЯ; АРГУМЕНТЫ; ТЕЛО и т.д.]). 

Тип DUMMY используется для определения ключевых слов и поддерживаемых операторов, это тоже, своего рода, отметка о распознанном типе, который получится из токена.

На выходе обработчика получается синтаксическое дерево.

## Интерпретатор

За счёт столь удобной структуры дерева, интерпретатор получается довольно простым: если нужно интерпретировать тип DUMMYLIST, то интерпретируются все его подвыражения таким образом, что вычисления закончатся, когда будет получено значение типа не `Expr.DUMMY`.

При интерпретации условного выражения оценивается условие, после чего возвращается соответствующая ветвь выражения (она не вычисляется при выражении).

Для именованной переменной происходит обращение к переменной окружения (в котором элементу также может соответствовать невычисленное выражение), которое и возвращается вместо переменной.

При объявлении функции в переменную окружения записывается информация о функции (имя, количество аргументов), в информацию о функции помещается также текущий контекст (переменная окружения) для поддержки замыканий.

При вызове функции проверяется совпадение арности объявленной и вызываемой функций, после чего происходит связывание аргументов функции с параметрами из вызова, которые вместе с запомненным окружением используются для интерпретации тела функции. При связывании добавляется в том числе и информация о самой функции, так что становится возможным её рекурсивный вызов.

Для операторов, которые взаимодействуют со списками аргументов сначала происходит оценка и проверка типов элементов списка, после чего происходит непосредственное вычисление значения.

Простейшие типы (число, строка, логическая переменная) при оценке возвращают себя же.

На выходе интерпретатора из-за требований в языке F# о возвращении из всех ветвей функции одного типа, возвращается один из подтипов типа Expr.

## Какие фишки вы реализовали

* [+] Именованные переменные
* [+] Рекурсия
* [+] Ленивые вычисления
* [+] Функции
* [+] Замыкания

## Getting Started

Присутствует возможность загрузки кода программы из файла, а также интерактивный интерпретатор repl (от англ. Read–eval–print loop).

### Математические выражения

Поддерживаемые математические операции - `+, -, *, /`.
Математические операции всегда окружаются круглыми скобками, внутри которых для этих операций передаются аргументы.
Аргументов может быть от одного и более. При передаче лишь одного аргумента `x` вызываются соответственно функции `x, (1 - x), x, (1 / x)`. 
В случае передачи множества аргументов первый из них выступает в роли начального, а после происходит свёртка списка аргументов (например, `(- x y z)` превращается в `x - y - z`).

#### Замечание

Внутри языка все числа представляются типом `double`, так что операция `%`, не поддерживается.

#### Примеры

``` 
  (+ 1 2) # превращается в 3

  (- 7) # превращается в -6
  
  (/ 2) # превращается в 0.5
  
  (* 1 2 3 4 5) # превращается в 120
```

### Булевые выражения

Поддерживаемые булевые операции - `&, |` - аналоги `and` и `or` соответственно.
Принцип их работы тот же, что и у математических операций, для списка аргументов длины 1, возвращается значение головы списка.

Булевые константы `true` и `false` записываются в коде программы с маленькой буквы без кавычек.

#### Замечание

Функциям могут передаваться как булевые аргументы, так и числовые, перевод числовых аргументов в булевые переходит по простому правилу - 0 переводится в false, всё остальное в true. 

#### Примеры

``` 
  (& true 0) # превращается в false

  (| false (< 1 2)) # превращается в true
```

### Строковые литералы
Объявляются как строка, обёрнутая двойными кавычками. Без кавычек будет распознано как название переменной/функции.

#### Пример
```
  ("string") # вернёт строку string
```

### Операторы отношения

Поддерживаются операторы - `>, <, =`. Все они бинарные и принимают на вход не более 2 аргументов, возвращают булевое значение. Сравнение возможно между строками, числами и булевыми значениями. 

#### Примеры

``` 
  (< 1.0 2.0) # превращается в true

  (> 2.7 4.2) # превращается в false
  
  (= "a" "b")
```

### Именованные переменные

Переменные создаются посредством синтаксиса - `(let id Expr)`. Значение `Expr` будет вычислено только при необходимости - в операциях возвращающих значение, `id` - строка без кавычек. Возвращаемое значение - `Expr.DUMMY`.

#### Примеры

``` 
  (let id 1) # в env будет записана запись о переменной со значением 1.
  
  (let id2 (+ 1 2)) # в env будет записана запись о переменной со значением OP(+, [1,2]), которое будет вычислено, например, в выражении (+ id2 1)
```

### Условные выражения

Условные выражения создаются посредством синтаксиса - `(if Expr then Expr else Expr)`, где ветвь `else` может быть опущена, вместо нее искусственно будет подставлен тип-пустышка `Expr.DUMMY`. При вызове будет оценено значение cond (булевое или приводимое к булевому значение), стоящее после if, значения ветвей сразу оценены не будут. Возвращаемое значение `Expr`.

#### Примеры

``` 
  (if true then 1 else 2) # вернёт 1.0
  
  (if false then 1) # вернёт DUMMY("")
```

### Функции

Функции создаются посредством синтаксиса - `(makefun function_name { arg1 arg2 } Expr )`, аргументов у функции может не быть, аргументы функции и `function_name`- строки без кавычек. При вызове функции происходит проверка количества аргументов и происходит их сопоставление - первый переданный сопоставляется имени первого аргумента функции и т.д.
За счёт замыканий любая функция может стать рекурсивной. Возвращаемое значение `Expr.DUMMY`.

#### Примеры

``` 
  (let id 1)
  
  (makefun id_1 {arg_1 arg_2 } ( + arg_1 arg_2 id )) # - объявлена функция c именем id_1, в которой находится словарь уже объявленных переменных, в котором находится переменная id.
  
  (id_1 1 2) # вернётся 4
  
  ((makefun id_1 {a} (if (> a 1) then ((print a) (id_1 (- a 1))) else \"function ended\")) (id_1 5)) @ рекурсивная функция, которая 
  выводит значения от 5 до 2, а потом завершается строкой "function ended" @
```

### Комментарии 

`#` - строчный комментарий - содержимое до конца строки отбрасывается.

`@...@` - комментарий от символа до символа - содержимое игнорируется от символа до символа вне зависимости от переносов строк. 

#### Примеры

``` 
  (+ 1 @ 1 2 3 @ 4) # вернётся 5
  
  (if true then 1) # комментарий к строке
```

### Функция печати 

Для вывода переменных может быть использована функция `print`, возможное типы значений для вывода - численный, строковый и булевый (речь про вычисленные типы значение).

#### Примеры

``` 
  (print 1) # выведет 1
  
  ((let id 1) (print id)) # выведет также 1
```

### Замечание

Синтаксис языка предполагает, что у корня распаршенного дерева имеется только один корень, так что все программы языка обрамляются дополнительными наружными скобками.
Большинство примеров в данном файле рассчитано на использование встроенной интерактивной утилиты repl, через которую возможно вводить программу построчно, будьте внимательны.

### Hello, world!
После прочтения данного пособия можно написать программу выводящую `Hello, World!` на экран компьютера.

`(print "Hello, World!")`

