# Функциональное программирование: Пишем компилятор!

Цель этой лабораторной работы - придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

Вы можете выполнить эту лабораторную работу в группе из 2 или 3 человек (или больше - но это требует одобрения преподавателя):

* 2 человека - компилятор/интерпретатор + примеры программ + краткая документация в README.md (вы можете заменить этот файл своей собственной документацией)
* 3 человека - компилятор/интерпретатор + примеры программ + более подробная документация на GitHub Pages
* 3 и более человек - помимо вышеуказанного, может включать следующее:
  - IDE в браузере
  - Поддержка Jupyter Notebook
  - Трансляция в JavaScript, чтобы можно было выполнять программу в браузере
  - Расширения для VS Code

## Задача

Ваша цель - изобрести и реализовать собственный функциональный язык программирования. Требования:

* Он должен тесно следовать парадигме функционального программирования, на основе либо [лямбда-исчисления](https://en.wikipedia.org/wiki/Lambda_calculus), либо [комбинаторной логики](https://en.wikipedia.org/wiki/Combinatory_logic).
* Он должен быть более или менее универсальным, т.е. реализовывать рекурсию. В идеале - полным по Тьюрингу.
* Как минимум, язык должен позволять запрограммировать функцию для расчета факториала.

> Имейте в виду, что написание парсеров - это утомительная задача, поэтому постарайтесь сделать синтаксис языка как можно проще.

Для вдохновения:

* Изучите [LISP](https://books.ifmo.ru/file/pdf/1918.pdf) - язык программирования с очень простым синтаксисом.
* Комбинаторные парсеры и библиотеку [fparsec](https://www.quanttec.com/fparsec/), если вы хотите реализовать язык с более сложным синтаксисом.
* [Top-Down Parser на F#](https://github.com/fholm/Vaughan).
* Интересный блог пост о [парсинге на F#](https://www.erikschierboom.com/2016/12/10/parsing-text-in-fsharp/).
* Парсинг с использованием инструментов [FsLex и FsYacc](https://realfiction.net/posts/lexing-and-parsing-in-f/) (не рекомендуется).
* Реализация [Scheme в F#](https://github.com/AshleyF/FScheme) - вы можете ознакомиться с этим проектом для вдохновения, но не заимствуйте код оттуда!

## Критерии оценки

* Универсальность
* Примеры программ (включая факториал, но не ограничиваясь им)
* Оригинальность и красота синтаксиса
* Документированность
* Красота реализации

Предпочтительный язык реализации - F#.

В документации явно укажите, какие функции языка вы реализовали:

* [+] Именованные переменные (`let`)
* [+] Рекурсия
* [ ] Ленивое вычисление
* [+] Функции
* [+] Замыкания
* [ ] Библиотечные функции: ввод-вывод файлов
* [ ] Списки / Последовательности
* [ ] Библиотечные функции: списки/последовательности

## Репозиторий

Вам необходимо работать над кодом в репозитории GitHub Classroom. После завершения задачи **настоятельно рекомендуется** форкнуть этот код в свои собственные аккаунты GitHub, чтобы он служил вашим портфолио.

## Пошаговая работа

Поскольку проект довольно большой, его нужно делать поэтапно, загружая ваш код в GitHub на каждом этапе:

* Этап 1: Разработка абстрактного синтаксического дерева и парсера для вашего языка + одна примерная программа.
* Этап 2: Разработка интерпретатора/компилятора для вашего языка.
* Этап 3: Написание примеров программ и документации.

> Конечно, вы можете изменять язык на более поздних этапах, если посчитаете это нужным.

## Авторы

Не забудьте упомянуть свою команду в файле README.md, указав также, кто что делал. Также файл README.md должен включать краткое руководство по вашему языку и некоторые короткие примеры кода.

Имя | Роль в проекте
------------------|---------------------
Люгге Томас | делал парсер, писал примеры и описание

## Реализованные функции языка

### Именованные переменные (аналог let)

Именованные переменные поддерживаются при помощи определения функций. Например, определение рекурсивной функции is_even.

Пример:
```
is_even = \n -> if n == 0 then true else is_odd(n - 1)
```

### Рекурсия

Реализована полная поддержка рекурсивных функций.

Пример:
Функция is_even использует рекурсивный вызов is_odd(n - 1).

```
is_even = \n -> if n == 0 then true else is_odd(n - 1)
```

### Функции

Функции реализованы через узлы Lambda и Application.

Пример:
```
fact = \n -> if n == 0 then 1 else n * fact(n - 1)
```

### Замыкания

Замыкания реализованы через лямбда-выражения. Лямбда-выражение захватывает параметры из внешнего контекста, создавая замыкание:

Пример:
```
fact = \n -> if n == 0 then 1 else n * fact(n - 1)
```

## Примеры программ

### Пример 1: Факториал

Рассматривается рекурсивная функция для вычисления факториала числа:

```
fact = \n -> if n == 0 then 1 else n * fact(n - 1)
result = fact(5)
120
```

### Пример 2: Фибоначчи

Функция для вычисления n-го числа Фибоначчи:

```
fib = \n -> if n == 0 then 0 else if n == 1 then 1 else fib(n - 1) + fib(n - 2)
result = fib(6)
8
```

### Пример 3: Проверка на простое число

Функция для проверки, является ли число простым (используя рекурсию):

```
>>> is_prime = \n -> \d -> if n == d then true else if n % d == 0 then false else is_prime(n)(d + 1)
>>> result = is_prime(5)(2)
true
>>> result = is_prime(6)(2)
false
```

## Заключение

В рамках данной лабораторной работы мы реализовали интерпретатор для простого функционального языка программирования с поддержкой переменных, рекурсии, функций и замыканий.
В дальнейших улучшениях можно добавить поддержку ленивых вычислений, работы со списками и ввода-вывода файлов.

Если необходимо реализовать другие конкретные примеры или функциональные возможности, сообщите об этом, и мы сможем включить их в будущие версии интерпретатора.
